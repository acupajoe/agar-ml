{"version":3,"sources":["webpack:///webpack/bootstrap 9974be31f440abd83b3c","webpack:///./src/settings.js","webpack:///./src/trainer.js","webpack:///./src/main.js","webpack:///./src/bot.js","webpack:///./src/game.js","webpack:///./src/food.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACjCA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B,qBAAqB,eAAe,uBAAuB;;AAE1F;;AAEA,0CAA0C,yBAAyB;AACnE,6CAA6C,uDAAuD;AACpG;;AAEA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;;AAEA,mBAAmB,2CAA2C;AAC9D;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACrFA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA,OAAO;AACP,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;AC/CA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,wEAA+B;AAClD;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,sEAA6B;AAChD;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;AC5KA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,mEAA0B;AAC7C;AACA;;AAEA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD,gBAAgB,KAAK,6DAAoB;AACjG;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,uEAA8B;AACjD;AACA;;AAEA,mBAAmB,wEAA+B;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AC1EA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9974be31f440abd83b3c","let width = window.innerWidth\nlet height = 600\n\nmodule.exports = {\n  width: width,\n  height: height,\n  area: {\n    min: 1000,\n    max: 10000\n  },\n  size: {\n    relative: 1.1,\n    decrease: 0.998\n  },\n  detection: {\n    food: 3,\n    player: 3,\n    radius: 250\n  },\n  speed: {\n    min: 0.3,\n    normal: 2\n  },\n  food: {\n    area: 100,\n    amount: Math.round(width * height * 4e-4)\n  },\n  bots: 15,\n  iterations: 1000,\n  startingHiddenSize: 0,\n  mutationRate: 0.4,\n  elitismPercent: 0.3,\n  isTrainedPop: false\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/settings.js\n// module id = 0\n// module chunks = 0","import Bot from './bot'\n\nconst settings = require('./settings')\n\nconst Neat = neataptic.Neat\nconst Methods = neataptic.Methods\nconst Architect = neataptic.Architect\n\nclass Trainer {\n  constructor () {\n    this.neat = new Neat(\n      1 + settings.detection.player * 3 + settings.detection.food * 2,\n      2,\n      null,\n      {\n        mutation: [\n          Methods.Mutation.ADD_NODE,\n          Methods.Mutation.SUB_NODE,\n          Methods.Mutation.ADD_CONN,\n          Methods.Mutation.SUB_CONN,\n          Methods.Mutation.MOD_WEIGHT,\n          Methods.Mutation.MOD_BIAS,\n          Methods.Mutation.MOD_ACTIVATION,\n          Methods.Mutation.ADD_GATE,\n          Methods.Mutation.SUB_GATE,\n          Methods.Mutation.ADD_SELF_CONN,\n          Methods.Mutation.ADD_BACK_CONN,\n          Methods.Mutation.SUB_BACK_CONN\n        ],\n        popsize: settings.bots,\n        mutationRate: settings.mutationRate,\n        elitism: Math.round(settings.elitismPercent * settings.bots),\n        network: new Architect.Random(\n          1 + settings.detection.player * 3 + settings.detection.food * 2,\n          settings.startingHiddenSize,\n          2\n        )\n      })\n    if (settings.isTrainedPop) {\n      // neat.population = population\n    }\n  }\n\n  start () {\n    window.Game.bots = []\n    for (let genome of this.neat.population) {\n      window.Game.bots.push(new Bot(genome))\n    }\n    document.getElementById('generation').innerText = this.neat.generation.toString()\n  }\n\n  end () {\n    let newPopulation = []\n\n    console.log(`Generation: ${this.neat.generation}, Avg Score: ${this.neat.getAverage()}`)\n\n    document.getElementById('average-fitness').innerText = Math.floor(this.neat.getAverage())\n\n    window.Chart.data.labels.push(`Gen. ${this.neat.generation + 1}`)\n    window.Chart.data.datasets[0].data.push({x: this.neat.generation + 1, y: this.neat.getAverage()})\n    window.Chart.update()\n\n    this.neat.sort()\n\n    for (let i = 0; i < this.neat.elitism; i++) {\n      newPopulation.push(this.neat.population[i])\n    }\n\n    for (let i = 0; i < this.neat.popsize - this.neat.elitism; i++) {\n      newPopulation.push(this.neat.getOffspring())\n    }\n\n    $.post('http://localhost:3000/store', {\n      generation: this.neat.generation + 1,\n      data: JSON.stringify(newPopulation)\n    })\n\n    this.neat.population = newPopulation\n    this.neat.mutate()\n    this.neat.generation++\n\n    this.start()\n  }\n}\n\nexport default (new Trainer())\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/trainer.js\n// module id = 1\n// module chunks = 0","import Trainer from './trainer'\nimport Game from './game'\n\nconst chartOptions = {\n  responsive: true,\n  maintainAspectRatio: false,\n  legend: {\n  },\n  scales: {\n    xAxes: [{\n      display: false\n    }],\n    yAxes: [{\n      display: false,\n      ticks: {\n        beginAtZero: true\n      }\n    }]\n  }\n}\n\nwindow.setup = function () {\n  let chart = document.getElementById('chart')\n  let context = chart.getContext('2d')\n\n  window.Chart = new Chart(context, {\n    type: 'line',\n    data: {\n      labels: ['Gen. 0'],\n      datasets: [{\n        label: 'Average Fitness',\n        data: [{x: 0, y: 0}],\n        backgroundColor: 'rgba(33,150,243, 0.4)'\n      }]\n    },\n    options: chartOptions\n  })\n\n  window.Game = new Game()\n  window.Trainer = Trainer\n  window.Trainer.start()\n}\n\nwindow.draw = function () {\n  clear()\n  window.Game.update()\n  window.Game.draw()\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/main.js\n// module id = 2\n// module chunks = 0","import settings from './settings'\n\nconst activationColor = (value, max) => {\n  let power = 1 - Math.min(value / max, 1)\n  let color = [255, 255, 0]\n\n  if (power < 0.5) {\n    color[0] = 2 * power * 255\n  } else {\n    color[1] = (1.0 - 2 * (power - 0.5)) * 255\n  }\n\n  return color\n}\n\nconst angleToPoint = (x1, y1, x2, y2) => {\n  let d = distance(x1, y1, x2, y2)\n  let dx = (x2 - x1) / d\n  let dy = (y2 - y1) / d\n\n  let a = Math.acos(dx)\n  return dy < 0 ? 2 * Math.PI - a : a\n}\n\nconst distance = (x1, y1, x2, y2) => Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2))\n\nexport default class Bot {\n  constructor (genome) {\n    this.x = Math.floor(Math.random() * settings.width)\n    this.y = Math.floor(Math.random() * settings.height)\n    this.vx = 0 // velocity x\n    this.vy = 0 // velocity y\n\n    this.cognition = genome\n    this.cognition.score = 0\n    this.area = settings.area.min\n    this.visualArea = this.area\n    this.aggro = this.area\n  }\n\n  update () {\n    if (this.area > settings.area.max) this.area = settings.area.max\n    if (this.area < settings.area.min) this.area = settings.area.min\n\n    let input = this.detect()\n    let output = this.cognition.activate(input)\n\n    let movementAngle = output[0] * 2 * Math.PI\n    let movementSpeed = output[1] > 1 ? 1 : output[1] < 0 ? 0 : output[1]\n\n    this.vx = movementSpeed * Math.cos(movementAngle) * settings.speed.normal\n    this.vy = movementSpeed * Math.sin(movementAngle) * settings.speed.normal\n\n    // Speed should be affected by size (larger = more cumbersome)\n    this.vx *= Math.max(1 - (this.area / settings.area.max), settings.speed.min / settings.speed.normal)\n    this.vy += Math.max(1 - (this.area / settings.area.max), settings.speed.min / settings.speed.normal)\n\n    this.x += this.vx\n    this.y += this.vy\n\n    // Force bot to stay in bounds\n    this.x = this.x >= settings.width ? this.x % settings.width : this.x <= 0 ? this.x + settings.width : this.x\n    this.y = this.y >= settings.height ? this.y % settings.height : this.y <= 0 ? this.y + settings.height : this.y\n\n    this.area *= settings.size.decrease\n\n    this.cognition.score = this.area\n\n    // Do we do better?\n    if (this.cognition.score > window.Game.highestFitness) {\n      window.Game.highestFitness = this.cognition.score\n      document.getElementById('highest-fitness').innerText = Math.floor(this.cognition.score)\n    }\n  }\n\n  draw () {\n    this.visualArea = lerp(this.visualArea, this.area, 0.2)\n    let radius = Math.sqrt(this.visualArea / Math.PI)\n    let color = activationColor(this.cognition.score, window.Game.highestFitness)\n\n    fill(color)\n    ellipse(this.x, this.y, radius)\n  }\n\n  reset () {\n    this.x = Math.floor(Math.random() * settings.width)\n    this.y = Math.floor(Math.random() * settings.height)\n    this.vx = 0\n    this.vy = 0\n    this.area = settings.area.min\n    this.visualArea = this.area\n  }\n\n  eat (obj) {\n    let d = distance(this.x, this.y, obj.x, obj.y)\n    let r1 = Math.sqrt(this.area / Math.PI)\n    let r2 = Math.sqrt(obj.area / Math.PI)\n\n    if (d < (r1 + r2) / 2 && this.area > obj.area * settings.size.relative) {\n      this.area += obj.area\n      obj.reset()\n      return true\n    }\n    return false\n  }\n\n  detect () {\n    let output = [this.area / settings.area.max]\n\n    let nearestFood = []\n    let distanceToFood = Array.apply(null, Array(settings.detection.food)).map(Number.prototype.valueOf, Infinity)\n\n    let nearestPlayers = []\n    let distanceToPlayers = Array.apply(null, Array(settings.detection.player)).map(Number.prototype.valueOf, Infinity)\n\n    for (let player of window.Game.bots) {\n      if (player === this || this.eat(player)) continue\n\n      let d = distance(this.x, this.y, player.x, player.y)\n      if (d < settings.detection.radius) {\n        let maxNearestDistance = Math.max.apply(null, distanceToPlayers)\n        let i = distanceToPlayers.indexOf(maxNearestDistance)\n\n        if (d < maxNearestDistance) {\n          distanceToPlayers[i] = d\n          nearestPlayers[i] = player\n        }\n      }\n    }\n\n    for (let food of window.Game.food) {\n      if (this.eat(food)) continue\n\n      let d = distance(this.x, this.y, food.x, food.y)\n      if (d < settings.detection.radius) {\n        let maxNearestDistance = Math.max.apply(null, distanceToFood)\n        let i = distanceToFood.indexOf(maxNearestDistance)\n\n        if (d < maxNearestDistance) {\n          distanceToFood[i] = d\n          nearestFood[i] = food\n        }\n      }\n    }\n\n    for (let i = 0; i < settings.detection.player; i++) {\n      let player = nearestPlayers[i]\n      let d = distanceToPlayers[i]\n\n      if (player === undefined) {\n        output = output.concat([0, 0, 0])\n      } else {\n        output.push(angleToPoint(this.x, this.y, player.x, player.y) / (2 * Math.PI))\n        output.push(d / settings.detection.radius)\n        output.push(player.area / settings.area.max)\n      }\n    }\n\n    for (let j = 0; j < settings.detection.food; j++) {\n      let food = nearestFood[j]\n      let d = distanceToFood[j]\n\n      if (food === undefined) {\n        output = output.concat([0, 0])\n      } else {\n        output.push(angleToPoint(this.x, this.y, food.x, food.y) / (2 * Math.PI))\n        output.push(d / settings.detection.radius)\n      }\n    }\n\n    return output\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/bot.js\n// module id = 3\n// module chunks = 0","import settings from './settings'\nimport Trainer from './trainer'\nimport Food from './food'\n\nclass Game {\n  constructor () {\n    this.food = []\n    this.bots = []\n    this.iterations = 0\n    this.highestFitness = 0\n\n    createCanvas(settings.width, settings.height)\n\n    for (let i = 0; i < settings.food.amount; i++) {\n      this.food.push(new Food())\n    }\n\n    if (!settings.isTrainedPop) {\n      for (let j = 0; j < 15; j++) {\n        Trainer.neat.mutate()\n      }\n    }\n  }\n\n  update () {\n    if (this.iterations === settings.iterations) {\n      Trainer.end()\n      this.iterations = 0\n    }\n\n    for (let bot of this.bots) {\n      bot.update()\n    }\n  }\n\n  draw () {\n    background(255)\n    this.drawGrid()\n    this.drawFood()\n    this.drawBots()\n\n    this.iterations++\n    document.getElementById('iteration').innerText = `${this.iterations} / ${settings.iterations}`\n  }\n\n  drawGrid () {\n    let spacing = 25\n    stroke(204, 204, 204, 160)\n    fill(255)\n\n    for (let x = 0; x < settings.width / spacing; x++) {\n      line(x * spacing, 0, x * spacing, settings.height)\n    }\n\n    for (let y = 0; y < settings.height / spacing; y++) {\n      line(0, y * spacing, settings.width, y * spacing)\n    }\n\n    noStroke()\n  }\n\n  drawFood () {\n    for (let food of this.food) {\n      food.draw()\n    }\n  }\n\n  drawBots () {\n    for (let bot of this.bots) {\n      bot.draw()\n    }\n  }\n}\n\nexport default Game\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/game.js\n// module id = 4\n// module chunks = 0","import settings from './settings'\n\nexport default class Food {\n  constructor () {\n    this.x = Math.floor(Math.random() * settings.width)\n    this.y = Math.floor(Math.random() * settings.height)\n    this.area = settings.food.area\n\n    this.color = [124, 252, 0]\n  }\n\n  draw () {\n    this.radius = Math.sqrt(this.area / Math.PI)\n\n    fill(this.color[0], this.color[1], this.color[2])\n    noStroke()\n    ellipse(this.x, this.y, this.radius)\n  }\n\n  reset () {\n    this.x = Math.floor(Math.random() * settings.width)\n    this.y = Math.floor(Math.random() * settings.height)\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/food.js\n// module id = 5\n// module chunks = 0"],"sourceRoot":""}